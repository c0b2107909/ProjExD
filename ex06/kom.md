
###　重要ポイント
# 盤面上の石の管理
- 今回は、盤面上の石の管理を2次元リストself.boardで行うようにしている。- self.board[y][x]に(x,y)の位置の交点に置かれている石の色を格納することで盤面上の石の管理を行う。
- 盤面上の状態が変化するのは「石が置かれたとき」。
- したがって、石が置かれたときには、このself.boardの更新を行う必要がある。(x,y)の一の交点に"black"の石が置かれる際には、石を置く処理だけではなく、self.board[y][x] = "black"とself.boardを更新する処理も合わせて実行する必要がある。

# 五目並べ画面の実現
- 今回は、五目並べの画面はキャンパス上にセント円を描画することで表現する。
- 盤面は縦方向と横方向にそれぞれ線を描画することで、表現する。線はキャンバスクラスのcreate_lineメソッドで描画する。
- 石は円を描画することで表現。この円は、キャンバスクラスのcreate_ovalメソッドで描画する。
- 石を描画するポイントは2つある。

# プレイヤーによって描画する円の色を変更する。
- 描画する円の塗りつぶし色は、create_oval実行時にfillオプションを指定することで設定可能.

# 縦線と横線の交点を中心に描画する
- 線と線の交点がキャンバス上のどの座標に位置するかを計算する必要がある。交点の位置(x,y)からのキャンバス上の座標の変換が必要
- 一番左上の交点のキャンバス上の座標を(self.offset_x,self.offset_y)、さらに線と線の間隔をself.intervalとすれば(x,y)の位置の交点は下記の式でキャンバス上の(center_x,center_y)に変換する事ができる。
- center_x = x * self.interval + self.offset_x
- center_y = y * self.interval + self.offset_y
- キャンバス上の円の中心座標が計算が可能となるので、後はこの円の中心座標からcreate_ovalメソッドに指定する円の開始座標と円の終了座標をもとめてやめれば良いです。
- 今回のスクリプトでは下記の式で円の開始座標(xs,xy)と円の終了座標(xe,ye)を計算しています。
- xs = center_x - (self.interval * 0.8) // 2
- ys = center_y - (self.interval * 0.8) // 2
- xe = center_x + (self.interval * 0.8) // 2
- ye = center_y + (self.interval * 0.8) // 2

# 石を置く処理の実現
- 今回は石を置く処理をキャンバス上をマウスでクリックされた際に実行するようにする。マウスクリックイベントの受付を行っている。
- self.canvas.bind("<ButtonPress>",self.click)
- ユーザーがクリックした位置に一番近い交点に石を置くようにする。
- 一番左上の交点のキャンバス上の座標(self.offset_x,self.offset_y)、さらに線と線の間隔をself.intervalとすれば、ユーザーがクリックした位置に一番近い交点の(ix,iy)はユーザーがクリックしたキャンバス上の座標(x,y)から下記のように計算することができます。
- ix = (x - self.offset_x + self.interval // 2) // self.interval
- iy = (y - self.offset_y + self.interval // 2) // self.interval

# 石が置ける位置
- ただし、盤面上の交点であればどこにでも石が置けるというわけではない。
- 石が置けるのはまだ石が置かれていない交点になる。
- したがって盤面上の石の管理で導入したself.boardを参照し、石を置こうとしている位置に既に石が置かれていないかどうかを確認してから石を置く必要がある。
- 例えば、(x,y)の位置に石を置こうとする場合、下記のようにself.board[y][x]がNoneであるかどうかを確認してから実際に石を置く処理を実行する必要がある。
- if not self.board[y][x]:#(x,y)に石を置く処理

# 並べられた石のカウント
- 1.count_numを1に初期化する
- 2.s=1に初期化する
- 3.self.board[y + j * s][x + i * s]が(x,y)に置かれた石の色と同じであるかを調べる
- 4.同じ色の場合
- count_num += 1を実行する
- s += 1を実行する
- 3.に戻る
- 5.s= -1に初期化
- 6.self.board[y + j * s][x + i * s]が(x,y)に置かれた石の色と同じであるかどうかを調べる
- 7.同じ色の場合
- count_num += 1を実行する
- s -= 1を実行する
- 6.に戻る
- 最終的なcount_numが、(x,y)の位置に石を置いたときに、(x,y)の位置の公転から方向i*jおよびその逆方向に連続して同じ色の石が並んでいる数になる。i*jは0と1の組み合わせからなる方向を示すパラメータである。例えば、i=1,j=1の場合はまず3.と4.で(x,y)から右下方向に対して連続して置かれた同じ色の石の数をカウントすることになる。5.以降はsが負の値になるので、今度は6.と7.で逆方向、つまり(x,y)から左上方向に対して連続しておかれた同じ色の色の数をカウントすることになる。全方向に対してこの石のカウントを行い、5以上の方向が存在した場合はゲーム終了になります。全方向に対して石の数をカウントするためには、五目並べの場合は4方向に対してループを組むようにすれば良い。
- i=1,j=0　右方向と左方向
- i=1,j=1　右下方向と左上方向
- i=0,j=1　上方向と下方向
- i=-1,j=1　左下方向と右上方向

# 関数の説明
- class Gobangの中で
- createWidgets関数：ウィジェット作成・配置する
- setEvent関数：イベントを設定する
- initGobang関数：ゲームの初期化を行う
- drawDisk関数：円を描画する
- getIntersection：キャンバス上の座標を交点の位置に変換
- click関数：盤面がクリックされたときの処理
- place関数：(x,y)の交点に色がcolorの石を置く
- count関数：(x,y)に色がcolorの石を置いたときの石の並び数をチェック
- showResult関数：ゲーム終了時の結果を表示する

# 原始的な五目並べからの変更点(追加？)
- 石の色変更
- 盤面の背景を変更
# 追加実装
- computerとの対戦から2人で対戦が可能に
# 参考文献
- だえうホームページ,[Python/tkinter]五目並べゲームの作り方,2022年11月8日参照,https://daeudaeu.com/tkinter-gobang/